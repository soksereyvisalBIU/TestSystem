import{u as O,a as v,e as C,b as R,c as E,s as S,f as y,g as w,w as M,Q}from"./suspense-r8NXFGOU.js";import{S as x,s as q,M as f,N as K,n as p,u as m,a as u,b as l,z as _,J as B}from"./app-qZM_P6kk.js";var k=class extends x{#e;#r=void 0;#t;#s;constructor(t,s){super(),this.#e=t,this.setOptions(s),this.bindMethods(),this.#i()}bindMethods(){this.mutate=this.mutate.bind(this),this.reset=this.reset.bind(this)}setOptions(t){const s=this.options;this.options=this.#e.defaultMutationOptions(t),q(this.options,s)||this.#e.getMutationCache().notify({type:"observerOptionsUpdated",mutation:this.#t,observer:this}),s?.mutationKey&&this.options.mutationKey&&f(s.mutationKey)!==f(this.options.mutationKey)?this.reset():this.#t?.state.status==="pending"&&this.#t.setOptions(this.options)}onUnsubscribe(){this.hasListeners()||this.#t?.removeObserver(this)}onMutationUpdate(t){this.#i(),this.#n(t)}getCurrentResult(){return this.#r}reset(){this.#t?.removeObserver(this),this.#t=void 0,this.#i(),this.#n()}mutate(t,s){return this.#s=s,this.#t?.removeObserver(this),this.#t=this.#e.getMutationCache().build(this.#e,this.options),this.#t.addObserver(this),this.#t.execute(t)}#i(){const t=this.#t?.state??K();this.#r={...t,isPending:t.status==="pending",isSuccess:t.status==="success",isError:t.status==="error",isIdle:t.status==="idle",mutate:this.mutate,reset:this.reset}}#n(t){p.batch(()=>{if(this.#s&&this.hasListeners()){const s=this.#r.variables,a=this.#r.context,r={client:this.#e,meta:this.options.meta,mutationKey:this.options.mutationKey};t?.type==="success"?(this.#s.onSuccess?.(t.data,s,a,r),this.#s.onSettled?.(t.data,null,s,a,r)):t?.type==="error"&&(this.#s.onError?.(t.error,s,a,r),this.#s.onSettled?.(void 0,t.error,s,a,r))}this.listeners.forEach(s=>{s(this.#r)})})}};function H(t,s,a){const r=O(),n=v(),o=m(),e=o.defaultQueryOptions(t);o.getDefaultOptions().queries?._experimental_beforeQuery?.(e),e._optimisticResults=r?"isRestoring":"optimistic",C(e),R(e,n),E(n);const c=!o.getQueryCache().get(e.queryHash),[i]=u.useState(()=>new s(o,e)),h=i.getOptimisticResult(e),b=!r&&t.subscribed!==!1;if(u.useSyncExternalStore(u.useCallback(d=>{const g=b?i.subscribe(p.batchCalls(d)):l;return i.updateResult(),g},[i,b]),()=>i.getCurrentResult(),()=>i.getCurrentResult()),u.useEffect(()=>{i.setOptions(e)},[e,i]),S(e,h))throw y(e,i,n);if(w({result:h,errorResetBoundary:n,throwOnError:e.throwOnError,query:o.getQueryCache().get(e.queryHash),suspense:e.suspense}))throw h.error;return o.getDefaultOptions().queries?._experimental_afterQuery?.(e,h),e.experimental_prefetchInRender&&!_&&M(h,r)&&(c?y(e,i,n):o.getQueryCache().get(e.queryHash)?.promise)?.catch(l).finally(()=>{i.updateResult()}),e.notifyOnChangeProps?h:i.trackResult(h)}function P(t,s){return H(t,Q)}function U(t,s){const a=m(),[r]=u.useState(()=>new k(a,t));u.useEffect(()=>{r.setOptions(t)},[r,t]);const n=u.useSyncExternalStore(u.useCallback(e=>r.subscribe(p.batchCalls(e)),[r]),()=>r.getCurrentResult(),()=>r.getCurrentResult()),o=u.useCallback((e,c)=>{r.mutate(e,c).catch(l)},[r]);if(n.error&&B(r.options.throwOnError,[n.error]))throw n.error;return{...n,mutate:o,mutateAsync:n.mutate}}export{P as a,U as u};
